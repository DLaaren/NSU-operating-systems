================= Статическая библиотека ==================

>>> Статическая библиотека = набор объёктных файлов, "архив" (примерно как .tar)

Чтобы собрать статическую библиотеку (name.lib для MSVC, name.a для GCC),
надо объёдинить объектные файлы (file.obj для MSVC, file.o для GCC).

Создание библиотеки выполняется отдельной программой:
  MSVC:
    lib   sum.obj prod.obj module.obj   /out:arithm.lib
    (если компилятор cl.exe виден в консоли, то и lib.exe тоже видна)
  GCC:
    ar rcs   arithm.a   sum.o prod.o module.o
    (что означает параметр rcs --- не знаю)

Чтобы использовать библиотеку, надо добавить её в линковку.
При этом линкер будет использовать все запакованные в неё объектные файлы.
  MSVC:
    cl /O2   main.c   arithm.lib
  GCC:
    gcc -O2  main.c   arithm.a              //ищет только в текущей директории
    gcc -O2  main.c   -l:arithm.a           //ищет только в library path (см. ниже)

Чтобы нормально использовать статическую библиотеку, кроме самого lib-файла
нужны также хедеры, в которых прописаны объявления доступных символов.

Если точнее: нужны "публичные" хедеры --- содержащие необходимые пользователю объявления.
В коде библиотеки также могут быть "приватные" хедеры --- они пользователю не нужны.

При подключении надо :

         (стат. библиотека)          (публичные хедеры)
            arithm.lib                    sum.h
          /                               prod.h
         /                                modulo.h
        /
       /                        1) настроить include path (чтобы хедеры были видны)
      | 2) добавить .lib-файл на вход линкеру
      | 3) настроить пути поиска библиотек линкером

Как настраивать пути в командной строке:
  include path (было раньше):
    MSVC:   cl     /I my/include/path
    GCC:   gcc     -I my/include/path
  library path (новое):
    MSVC:   cl     /link/libpath:my/library/path        //ВАЖНО: лучше писать в КОНЦЕ командной строки
    GCC:   gcc     -L my/library/path                   //ВАЖНО: работает только при подключении типа "-l:mylib.a"


Полный сценарий:

 Создание стат. библиотеки:                     Использование стат. библиотеки:
1) Компилируем всё, НЕ линкуем                 1) Кладём .lib-файл и хедеры куда хотим
2) Собираем .lib-файл (lib/ar)                 2) Включаем эти хедеры в своих TU             
3) Определяем публичные хедеры                    Используем там всякие функции из библиотеки
4) Выдаём пользователю:                        2a) Возможно правим include paths, 
     .lib-файл                                    чтобы хедеры находил компилятор
     публичные хедеры                          3) Добавляем .lib-файл на вход линкеру
                                               3a) Возможно правим library paths

Тонкий вопрос: будет ли .lib работать при линковке на других: машине, компиляторе, версии и настройках ?
Это вопрос о бинарной совместимости объектных файлов --- надо смотреть, что гарантирует конкретный компилятор.
(пример: на MSVC для языка C++ чаще всего НЕ совместимы .obj-файлы Debug/Release)


>>> Сборка программы или библиотеки скриптом:
       Windows                   Linux/Unix
   batch: .bat, .cmd          shell/bash: .sh

В обеих системах есть скриптовый язык.
В простейших случаях скрипт --- это последовательность команд, которые надо по очереди запустить в консоли.
Такой скрипт работает одинаково и в batch, и в shell.
Разумеется, в скриптах есть более сложные возможности: if-ы, циклы, проверка кода возврата и т.п.

Пример простого скрипта (содержимое build.bat):
  cl min.c max.c array.c /O2 /c
  cl megacode.c /c
  cl min.obj max.obj array.obj megacode.obj /Fe"MyCoolProgram.exe"
Скрипт можно запустить так же, как любую обычную программу.


===================== Псевдошаблоны ====================

Псевдошаблон --- аналог template из C++.

Мотивация: мы часто пишем растущий массив в задачах.
В каждой задаче он пишется одинаково, но тип хранимых элементов разный.
Было бы неплохо написать один раз хедер, и использовать его везде напрямую.

Выход: надо написать шаблон, а потом каким-то образом сгенерировать код по этому шаблону много раз.
Для генерации кода подходит препроцессор.
Конкретнее --- директива #include   (БЕЗ стража включения!)


Рассмотрим задачу: написать псевдошаблон вектора для векторной математики.
Размерность может быть: 2 (плоскость), 3 (пространство) или 4 (однородные координаты)
Элемент может быть типа: double (моделирование), float (игры) или int (точная арифметика)

Будем генерировать код для вектора так (vectors.h):
  #pragma once

  #define TYPE double                       //TYPE и NUM --- параметры шаблона
  #define NUM 3                             //эти макросы надо установить перед #include
  #include "vector_template.h"              //генерируем код для 3D-вектора с double 

  #define TYPE int
  #define NUM 2
  #include "vector_template.h"              //генерируем код для 2D-вектора с int

  #define TYPE float
  #define NUM 2
  #include "vector_template.h"              //генерируем код для 2D-вектора с float

Внутри хедера vector_template.h должен быть код вектора:
  //важно: здесь НЕТ стража включения!
  typedef struct Vector {
    TYPE a[NUM];
  } Vector;
  static inline Vector add(Vector a, Vector b) { ... }          //static inline --- чтобы можно было
  static inline Vector sub(Vector a, Vector b) { ... }          //писать код функций прямо в хедере
  
В C нельзя иметь структуры и функции с одинаковыми именами.
Поэтому надо, чтобы имена структур и функций зависели от параметров шаблона, например:
  Vector_double_3 вместо Vector
  add_double_3 вместо add

Для этого нужна новая возможность препроцессора:
  #define TCAT3(a, b, c) a##_##b##_##c
  #define CAT3(a, b, c) TCAT3(a, b, c)
Теперь в vector_template.h можно написать:
  #define VECTOR CAT3(Vector, TYPE, NUM)
  typedef struct VECTOR {
    TYPE a[NUM];
  } VECTOR;
  static VECTOR CAT3(add, TYPE, NUM) (VECTOR a, VECTOR b) { ... }
  static VECTOR CAT3(sub, TYPE, NUM) (VECTOR a, VECTOR b) { ... }

Пояснение:
1) Связка ## говорит препроцессору сконкатенировать (склеить) токены в один.
2) Промежуточный макрос необходим:
     TCAT3(Vector, TYPE, NUM)  --->  Vector_TYPE_NUM
     CAT3(Vector, TYPE, NUM)   --->  Vector_double_3
  (почему так --- сложно сказать)

Заметим, что:
1) Обычно хочется иметь в vectors.h только объявления, а в vectors.c --- только определения.
  В таком случае вместо vector_template.h надо сделать два специальных хедера-шаблона: vector_decl.h и vector_def.h.
  В файле vectors.h надо подключать vector_decl.h, а в файле vectors.c подключать vector_def.h.
  Если лень, можно сделать только vectors.h и vector_decl.h, но тогда надо пометить все функции как static.
2) В жизни я бы предпочёл иметь короткие имена вроде Vec3d/Vec2i и add3d/add2i.
  К счастью, это легко можно настроить.
  Можно например перед подключением хедера делать "#define SUFFIX 3d" и потом конкатенировать к именам этот суффикс.
3) Указанный способ реализации псевдошаблона дружелюбен к отладчику.
  Весь псевдошаблонный код отлично отлаживается, как минимум в MSVC.


======================= X-макросы ======================

Мотивация: есть структура конфига программы, в ней много полей.
Хочется, чтобы конфиг можно было писать в файл и читать из файла.

Проблема в том, что список полей необходимо писать три раза:
  1) При описании полей
  2) В коде записи
  3) В коде чтения
Естественно, если список полей часто меняется, можно добавить поле, но забыть добавить его запись/чтение.

Решение --- использовать макрос-функцию, которая принимает как аргумент другую макро-функцию (X-макрос).
Получается некоторое "функциональное программирование на препроцессоре".
В определении макроса список всех параметров: вся информация о каждом параметре передаётся в X-макрос.

Список параметров:
  #define PARAMS_LIST(X) \
    X(version, int) \
    X(max_engine_power, double) \
    X(vendor, char*) \
    X(fuel_type, int) \
    X(fuel_tank_capacity, double) \
    X(has_morality_core, int)

Объявление структуры:
  struct Config {
    #define DEF_MEMBER(name, type) type name;
    PARAMS_LIST(DEF_MEMBER)
  };